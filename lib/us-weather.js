// Generated by CoffeeScript 1.6.3
var DataNameMap, JL, JS, URL, URLprefix, WeatherParms, findElement, findElements, getDate, getHttp, getOneTimeInvoker, getParameterData, getText, getTimeLayouts, handle_getLocations, handle_getWeather, help, htmlParser, http, main, normalizeElements, parseXML, pkg, select, soupSelect, util, valueParserFloat, valueParserInt, weather, _;

URL = require("url");

http = require("http");

util = require("util");

_ = require("underscore");

htmlParser = require("htmlparser");

soupSelect = require("soupselect");

select = soupSelect.select;

pkg = require("../package.json");

weather = exports;

URLprefix = "http://graphical.weather.gov/xml/sample_products/browser_interface/ndfdXMLclient.php";

DataNameMap = {
  "Temperature": "temp",
  "Dew Point Temperature": "dew",
  "Apparent Temperature": "appt",
  "12 Hourly Probability of Precipitation": "pop12",
  "Liquid Precipitation Amount": "qpf",
  "Snow Amount": "snow",
  "Ice Accumulation": "iceaccum",
  "Cloud Cover Amount": "sky",
  "Relative Humidity": "rh"
};

WeatherParms = _.values(DataNameMap);

WeatherParms = _.map(WeatherParms, function(parm) {
  return "" + parm + "=" + parm;
});

WeatherParms = WeatherParms.join("&");

main = function(args) {
  var lat, lon, zip;
  if (args[0] === "serve") {
    return require("./server");
  } else if (args[0] === "locations") {
    return weather.getLocations(function(err, data) {
      return console.log(JL(data));
    });
  } else if (args.length === 1) {
    zip = parseInt(args[0], 10);
    if (isNaN(zip)) {
      help();
    }
    return weather.getWeatherByZip(zip, function(err, data) {
      return console.log(JL(data));
    });
  } else if (args.length === 2) {
    lat = parseFloat(args[0]);
    lon = parseFloat(args[1]);
    if (isNaN(lat || isNan(lon))) {
      help();
    }
    return weather.getWeatherByGeo(lat, lon, function(err, data) {
      return console.log(JL(data));
    });
  } else {
    return help();
  }
};

help = function() {
  console.log("usage:");
  console.log("    " + pkg.name + " <arguments>");
  console.log("");
  console.log("arguments:");
  console.log("    serve       - start an http server");
  console.log("    locations   - display locations");
  console.log("    <num>       - weather for zip code");
  console.log("    <num> <num> - weather for latitude / longitude");
  return process.exit(1);
};

weather.getLocations = function(callback) {
  var url;
  callback = getOneTimeInvoker(callback);
  url = "" + URLprefix + "?listCitiesLevel=1234";
  getHttp(url, function(err, body) {
    if (err != null) {
      return callback(err);
    }
    try {
      return handle_getLocations(body, callback);
    } catch (_error) {
      err = _error;
      return callback(err);
    }
  });
};

weather.getWeatherByZip = function(zipcode, callback) {
  var parsedZipcode, url;
  parsedZipcode = parseInt("" + zipcode);
  if (isNaN(parsedZipcode)) {
    callback(Error("zipcode value is not an integer"));
    return;
  }
  callback = getOneTimeInvoker(callback);
  url = "" + URLprefix + "?product=time-series&zipCodeList=" + zipcode;
  getHttp(url, function(err, body) {
    if (err != null) {
      return callback(err);
    }
    try {
      return handle_getWeather(body, callback);
    } catch (_error) {
      err = _error;
      return callback(err);
    }
  });
};

weather.getWeatherByGeo = function(lat, lon, callback) {
  var parsedLat, parsedLon, url;
  parsedLat = parseFloat("" + lat);
  if (isNaN(parsedLat)) {
    callback(Error("latitude value is not a number"));
    return;
  }
  parsedLon = parseFloat("" + lon);
  if (isNaN(parsedLon)) {
    callback(Error("longitude value is not a number"));
    return;
  }
  callback = getOneTimeInvoker(callback);
  url = "" + URLprefix + "?product=time-series&listLatLon=" + lat + "," + lon + "&" + WeatherParms;
  getHttp(url, function(err, body) {
    if (err != null) {
      return callback(err);
    }
    try {
      return handle_getWeather(body, callback);
    } catch (_error) {
      err = _error;
      return callback(err);
    }
  });
};

handle_getLocations = function(xml, callback) {
  var city, cn, cnList, dom, i, lat, ll, llList, lon, result, st, _i, _ref, _ref1, _ref2;
  dom = parseXML(xml);
  llList = getText(select(dom, "latlonlist"));
  cnList = getText(select(dom, "citynamelist"));
  llList = llList.split(" ");
  cnList = cnList.split("|");
  result = [];
  for (i = _i = 0, _ref = llList.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    ll = llList[i];
    cn = cnList[i];
    _ref1 = ll.split(","), lat = _ref1[0], lon = _ref1[1];
    _ref2 = cn.split(","), city = _ref2[0], st = _ref2[1];
    lat = parseFloat(lat);
    lon = parseFloat(lon);
    result.push({
      lat: lat,
      lon: lon,
      city: city,
      st: st
    });
  }
  callback(null, result);
};

handle_getWeather = function(xml, callback) {
  var dataSets, dom, name, parser, point, result, selector, timeLayouts, values, _i, _len, _ref, _ref1;
  result = {};
  dom = parseXML(xml);
  result.date = getDate(select(dom, "creationdate"));
  point = select(dom, "data location point")[0];
  result.lat = parseFloat(point.attribs.latitude);
  result.lon = parseFloat(point.attribs.longitude);
  timeLayouts = getTimeLayouts(dom);
  result.data = {};
  dataSets = [['temperature[type="hourly"]', valueParserInt], ['temperature[type="dewpoint"]', valueParserInt], ['temperature[type="apparent"]', valueParserInt], ['precipitation[type="liquid"]', valueParserFloat], ['precipitation[type="snow"]', valueParserFloat], ['precipitation[type="ice"]', valueParserFloat], ['cloudamount', valueParserInt], ['probabilityofprecipitation', valueParserInt], ['humidity', valueParserInt]];
  for (_i = 0, _len = dataSets.length; _i < _len; _i++) {
    _ref = dataSets[_i], selector = _ref[0], parser = _ref[1];
    _ref1 = getParameterData(dom, timeLayouts, selector, parser), name = _ref1.name, values = _ref1.values;
    name = DataNameMap[name];
    result.data[name] = values;
  }
  callback(null, result);
};

getParameterData = function(dom, timeLayouts, elementName, parser) {
  var date, elements, i, layout, len, name, rawValues, value, values, _i;
  elements = select(dom, "data parameters " + elementName);
  layout = elements[0].attribs["time-layout"];
  layout = timeLayouts[layout];
  name = getText(select(elements, "name"));
  values = select(elements, "value");
  rawValues = _.map(values, function(value) {
    return parser(value);
  });
  len = Math.min(values.length, layout.length);
  values = [];
  for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
    date = layout[i];
    value = rawValues[i];
    values.push({
      date: date,
      value: value
    });
  }
  return {
    name: name,
    values: values
  };
};

valueParserInt = function(dom) {
  var text, value;
  text = getText(dom);
  value = parseInt(text, 10);
  if (isNaN(value)) {
    value = 0;
  }
  return value;
};

valueParserFloat = function(dom) {
  var text, value;
  text = getText(dom);
  value = parseFloat(text);
  if (isNaN(value)) {
    value = 0.0;
  }
  return value;
};

getTimeLayouts = function(dom) {
  var key, layoutElement, layoutElements, result, timeElements, times, _i, _len;
  result = {};
  layoutElements = select(dom, "timelayout");
  for (_i = 0, _len = layoutElements.length; _i < _len; _i++) {
    layoutElement = layoutElements[_i];
    key = getText(select(layoutElement, "layoutkey"));
    timeElements = select(layoutElement, "startvalidtime");
    times = _.map(timeElements, function(timeElement) {
      return getDate(timeElement);
    });
    result[key] = times;
  }
  return result;
};

findElements = function(nodes, tag, result) {
  var node, _i, _len;
  result = result || [];
  for (_i = 0, _len = nodes.length; _i < _len; _i++) {
    node = nodes[_i];
    if (node.type === "tag") {
      if (node.name === tag) {
        result.push(node);
      }
    }
    if (node.children != null) {
      findElements(node.children, tag, result);
    }
  }
  return result;
};

findElement = function(nodes, tag, result) {
  var elements;
  elements = findElements(nodes, tag);
  return elements[0];
};

getDate = function(nodes) {
  var date, text;
  text = getText(nodes);
  date = new Date(text);
  return date.toISOString().replace("T", " ");
};

getText = function(nodes, result) {
  var node, _i, _len;
  if (!_.isArray(nodes)) {
    nodes = [nodes];
  }
  result = result || "";
  for (_i = 0, _len = nodes.length; _i < _len; _i++) {
    node = nodes[_i];
    if (node.type === "text") {
      result += node.data;
    }
    if (node.children != null) {
      result = getText(node.children, result);
    }
  }
  return result;
};

parseXML = function(body) {
  var handler, parser, result;
  result = null;
  handler = new htmlParser.DefaultHandler(function(err, nodes) {
    if (err == null) {
      return result = nodes;
    }
  });
  parser = new htmlParser.Parser(handler);
  parser.parseComplete(body);
  normalizeElements(result);
  return result;
};

normalizeElements = function(nodes) {
  var node, _i, _len;
  if (nodes == null) {
    return;
  }
  if (!_.isArray(nodes)) {
    nodes = [nodes];
  }
  for (_i = 0, _len = nodes.length; _i < _len; _i++) {
    node = nodes[_i];
    if (node.type !== "tag") {
      continue;
    }
    node.name = node.name.toLowerCase();
    node.name = node.name.replace(/-/g, "");
    if (node.attribs) {
      if (node.attribs["type"]) {
        node.attribs["type"] = node.attribs["type"].replace(/\s+/, "");
      }
    }
    normalizeElements(node.children);
  }
};

getHttp = function(url, callback) {
  var request;
  url = URL.parse(url);
  request = http.request(url);
  request.on("response", function(response) {
    var body;
    body = "";
    if (response.statusCode !== 200) {
      callback(Error("http status: " + response.statusCode));
    }
    response.setEncoding("utf8");
    response.on("data", function(chunk) {
      return body += chunk;
    });
    response.on("end", function() {
      return callback(null, body);
    });
    return response.on("error", function(err) {
      return callback(err);
    });
  });
  request.on("error", function(err) {
    return callback(err);
  });
  request.end();
};

getOneTimeInvoker = function(callback) {
  var called;
  called = false;
  return function(err, data) {
    if (called) {
      return;
    }
    called = true;
    return callback(err, data);
  };
};

JS = function(object) {
  return JSON.stringify(object);
};

JL = function(object) {
  return JSON.stringify(object, null, 4);
};

if (require.main === module) {
  main(process.argv.slice(2));
}
